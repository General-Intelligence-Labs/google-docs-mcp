This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomix/
  bundles.json
docs/
  index.html
src/
  auth.ts
  server.ts
.gitignore
LICENSE
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomix/bundles.json">
{
  "bundles": {}
}
</file>

<file path="src/auth.ts">
// src/auth.ts
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as readline from 'readline/promises';
import { fileURLToPath } from 'url';

// --- Calculate paths relative to this script file (ESM way) ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRootDir = path.resolve(__dirname, '..');

const TOKEN_PATH = path.join(projectRootDir, 'token.json');
const CREDENTIALS_PATH = path.join(projectRootDir, 'credentials.json');
// --- End of path calculation ---

const SCOPES = [
  'https://www.googleapis.com/auth/documents',
  'https://www.googleapis.com/auth/drive.file' // Or scope used in Step 1
];

async function loadSavedCredentialsIfExist(): Promise<OAuth2Client | null> {
  try {
    const content = await fs.readFile(TOKEN_PATH);
    const credentials = JSON.parse(content.toString());
    const { client_secret, client_id, redirect_uris } = await loadClientSecrets();
    const client = new google.auth.OAuth2(client_id, client_secret, redirect_uris?.[0]);
    client.setCredentials(credentials);
    return client;
  } catch (err) {
    return null;
  }
}

async function loadClientSecrets() {
  const content = await fs.readFile(CREDENTIALS_PATH);
  const keys = JSON.parse(content.toString());
  const key = keys.installed || keys.web;
   if (!key) throw new Error("Could not find client secrets in credentials.json.");
  return {
      client_id: key.client_id,
      client_secret: key.client_secret,
      redirect_uris: key.redirect_uris
  };
}

async function saveCredentials(client: OAuth2Client): Promise<void> {
  const { client_secret, client_id } = await loadClientSecrets();
  const payload = JSON.stringify({
    type: 'authorized_user',
    client_id: client_id,
    client_secret: client_secret,
    refresh_token: client.credentials.refresh_token,
  });
  await fs.writeFile(TOKEN_PATH, payload);
  console.error('Token stored to', TOKEN_PATH);
}

async function authenticate(): Promise<OAuth2Client> {
  const { client_secret, client_id, redirect_uris } = await loadClientSecrets();
  const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uris?.[0]);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

  const authorizeUrl = oAuth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: SCOPES.join(' '),
  });

  console.error('Authorize this app by visiting this url:', authorizeUrl);
  const code = await rl.question('Enter the code from that page here: ');
  rl.close();

  try {
    const { tokens } = await oAuth2Client.getToken(code);
    oAuth2Client.setCredentials(tokens);
    if (tokens.refresh_token) { // Save only if we got a refresh token
         await saveCredentials(oAuth2Client);
    } else {
         console.error("Did not receive refresh token. Token might expire.");
    }
    console.error('Authentication successful!');
    return oAuth2Client;
  } catch (err) {
    console.error('Error retrieving access token', err);
    throw new Error('Authentication failed');
  }
}

export async function authorize(): Promise<OAuth2Client> {
  let client = await loadSavedCredentialsIfExist();
  if (client) {
    // Optional: Add token refresh logic here if needed, though library often handles it.
    console.error('Using saved credentials.');
    return client;
  }
  console.error('Starting authentication flow...');
  client = await authenticate();
  return client;
}
</file>

<file path=".gitignore">
# Node dependencies
node_modules/
dist/

# Credentials / Tokens
credentials.json
token.json

# Log files
*.log

# Environment variables (if you use a .env file later)
.env*
</file>

<file path="LICENSE">
https://opensource.org/license/MIT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="package.json">
{
  "name": "mcp-googledocs-server",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "fastmcp": "^1.21.0",
    "google-auth-library": "^9.15.1",
    "googleapis": "^148.0.0",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/node": "^22.14.1",
    "tsx": "^4.19.3",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="tsconfig.json">
// tsconfig.json
{
    "compilerOptions": {
      "target": "ES2022",
      "module": "NodeNext",
      "moduleResolution": "NodeNext",
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
  }
</file>

<file path="docs/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastMCP Google Docs Server Docs</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        pre { background-color: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto; }
        code { font-family: monospace; }
        h1, h2, h3 { border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 20px; }
    </style>
</head>
<body>
    <div id="content"></div>

    <script type="text/markdown" id="markdown-content">
# FastMCP Google Docs Server

Connect Claude Desktop (or other MCP clients) to your Google Docs!

This server uses the Model Context Protocol (MCP) and the `fastmcp` library to provide tools for reading and appending text to Google Documents. It acts as a bridge, allowing AI assistants like Claude to interact with your documents programmatically.

**Features:**

- **Read Documents:** Provides a `readGoogleDoc` tool to fetch the text content of a specified Google Doc.
- **Append to Documents:** Provides an `appendToGoogleDoc` tool to add text to the end of a specified Google Doc.
- **Google Authentication:** Handles the OAuth 2.0 flow to securely authorize access to your Google Account.
- **MCP Compliant:** Designed for use with MCP clients like Claude Desktop.

---

## Prerequisites

Before you start, make sure you have:

1.  **Node.js and npm:** A recent version of Node.js (which includes npm) installed on your computer. You can download it from [nodejs.org](https://nodejs.org/). (Version 18 or higher recommended).
2.  **Git:** Required for cloning this repository. ([Download Git](https://git-scm.com/downloads)).
3.  **A Google Account:** The account that owns or has access to the Google Docs you want to interact with.
4.  **Command Line Familiarity:** Basic comfort using a terminal or command prompt (like Terminal on macOS/Linux, or Command Prompt/PowerShell on Windows).
5.  **Claude Desktop (Optional):** If your goal is to connect this server to Claude, you'll need the Claude Desktop application installed.

---

## Setup Instructions

Follow these steps carefully to get your own instance of the server running.

### Step 1: Google Cloud Project & Credentials (The Important Bit!)

This server needs permission to talk to Google APIs on your behalf. You'll create special "keys" (credentials) that only your server will use.

1.  **Go to Google Cloud Console:** Open your web browser and go to the [Google Cloud Console](https://console.cloud.google.com/). You might need to log in with your Google Account.
2.  **Create or Select a Project:**
    - If you don't have a project, click the project dropdown near the top and select "NEW PROJECT". Give it a name (e.g., "My MCP Docs Server") and click "CREATE".
    - If you have existing projects, you can select one or create a new one.
3.  **Enable APIs:** You need to turn on the specific Google services this server uses.
    - In the search bar at the top, type "APIs & Services" and select "Library".
    - Search for "**Google Docs API**" and click on it. Then click the "**ENABLE**" button.
    - Search for "**Google Drive API**" and click on it. Then click the "**ENABLE**" button (this is often needed for finding files or permissions).
4.  **Configure OAuth Consent Screen:** This screen tells users (usually just you) what your app wants permission for.
    - On the left menu, click "APIs & Services" -> "**OAuth consent screen**".
    - Choose User Type: Select "**External**" and click "CREATE".
    - Fill in App Information:
      - **App name:** Give it a name users will see (e.g., "Claude Docs MCP Access").
      - **User support email:** Select your email address.
      - **Developer contact information:** Enter your email address.
    - Click "**SAVE AND CONTINUE**".
    - **Scopes:** Click "**ADD OR REMOVE SCOPES**". Search for and add the following scopes:
      - `https://www.googleapis.com/auth/documents` (Allows reading/writing docs)
      - `https://www.googleapis.com/auth/drive.file` (Allows access to specific files opened/created by the app)
      - Click "**UPDATE**".
    - Click "**SAVE AND CONTINUE**".
    - **Test Users:** Click "**ADD USERS**". Enter the same Google email address you are logged in with. Click "**ADD**". This allows _you_ to use the app while it's in "testing" mode.
    - Click "**SAVE AND CONTINUE**". Review the summary and click "**BACK TO DASHBOARD**".
5.  **Create Credentials (The Keys!):**
    - On the left menu, click "APIs & Services" -> "**Credentials**".
    - Click "**+ CREATE CREDENTIALS**" at the top and choose "**OAuth client ID**".
    - **Application type:** Select "**Desktop app**" from the dropdown.
    - **Name:** Give it a name (e.g., "MCP Docs Desktop Client").
    - Click "**CREATE**".
6.  **⬇️ DOWNLOAD THE CREDENTIALS FILE:** A box will pop up showing your Client ID. Click the "**DOWNLOAD JSON**" button.
    - Save this file. It will likely be named something like `client_secret_....json`.
    - **IMPORTANT:** Rename the downloaded file to exactly `credentials.json`.
7.  ⚠️ **SECURITY WARNING:** Treat this `credentials.json` file like a password! Do not share it publicly, and **never commit it to GitHub.** Anyone with this file could potentially pretend to be _your application_ (though they'd still need user consent to access data).

### Step 2: Get the Server Code

1.  **Clone the Repository:** Open your terminal/command prompt and run:
    ```bash
    git clone https://github.com/a-bonus/google-docs-mcp.git mcp-googledocs-server
    ```
2.  **Navigate into Directory:**
    ```bash
    cd mcp-googledocs-server
    ```
3.  **Place Credentials:** Move or copy the `credentials.json` file you downloaded and renamed (from Step 1.6) directly into this `mcp-googledocs-server` folder.

### Step 3: Install Dependencies

Your server needs some helper libraries specified in the `package.json` file.

1.  In your terminal (make sure you are inside the `mcp-googledocs-server` directory), run:
    ```bash
    npm install
    ```
    This will download and install all the necessary packages into a `node_modules` folder.

### Step 4: Build the Server Code

The server is written in TypeScript (`.ts`), but we need to compile it into JavaScript (`.js`) that Node.js can run directly.

1.  In your terminal, run:
    ```bash
    npm run build
    ```
    This uses the TypeScript compiler (`tsc`) to create a `dist` folder containing the compiled JavaScript files.

### Step 5: First Run & Google Authorization (One Time Only)

Now you need to run the server once manually to grant it permission to access your Google account data. This will create a `token.json` file that saves your permission grant.

1.  In your terminal, run the _compiled_ server using `node`:
    ```bash
    node ./dist/server.js
    ```
2.  **Watch the Terminal:** The script will print:
    - Status messages (like "Attempting to authorize...").
    - An "Authorize this app by visiting this url:" message followed by a long `https://accounts.google.com/...` URL.
3.  **Authorize in Browser:**
    - Copy the entire long URL from the terminal.
    - Paste the URL into your web browser and press Enter.
    - Log in with the **same Google account** you added as a Test User in Step 1.4.
    - Google will show a screen asking for permission for your app ("Claude Docs MCP Access" or similar) to access Google Docs/Drive. Review and click "**Allow**" or "**Grant**".
4.  **Get the Authorization Code:**
    - After clicking Allow, your browser will likely try to redirect to `http://localhost` and show a **"This site can't be reached" error**. **THIS IS NORMAL!**
    - Look **carefully** at the URL in your browser's address bar. It will look like `http://localhost/?code=4/0Axxxxxxxxxxxxxx&scope=...`
    - Copy the long string of characters **between `code=` and the `&scope` part**. This is your single-use authorization code.
5.  **Paste Code into Terminal:** Go back to your terminal where the script is waiting ("Enter the code from that page here:"). Paste the code you just copied.
6.  **Press Enter.**
7.  **Success!** The script should print:
    - "Authentication successful!"
    - "Token stored to .../token.json"
    - It will then finish starting and likely print "Awaiting MCP client connection via stdio..." or similar, and then exit (or you can press `Ctrl+C` to stop it).
8.  ✅ **Check:** You should now see a new file named `token.json` in your `mcp-googledocs-server` folder.
9.  ⚠️ **SECURITY WARNING:** This `token.json` file contains the key that allows the server to access your Google account _without_ asking again. Protect it like a password. **Do not commit it to GitHub.** The included `.gitignore` file should prevent this automatically.

### Step 6: Configure Claude Desktop (Optional)

If you want to use this server with Claude Desktop, you need to tell Claude how to run it.

1.  **Find Your Absolute Path:** You need the full path to the server code.
    - In your terminal, make sure you are still inside the `mcp-googledocs-server` directory.
    - Run the `pwd` command (on macOS/Linux) or `cd` (on Windows, just displays the path).
    - Copy the full path (e.g., `/Users/yourname/projects/mcp-googledocs-server` or `C:\Users\yourname\projects\mcp-googledocs-server`).
2.  **Locate `mcp_config.json`:** Find Claude's configuration file:
    - **macOS:** `~/Library/Application Support/Claude/mcp_config.json` (You might need to use Finder's "Go" -> "Go to Folder..." menu and paste `~/Library/Application Support/Claude/`)
    - **Windows:** `%APPDATA%\Claude\mcp_config.json` (Paste `%APPDATA%\Claude` into File Explorer's address bar)
    - **Linux:** `~/.config/Claude/mcp_config.json`
    - _If the `Claude` folder or `mcp_config.json` file doesn't exist, create them._
3.  **Edit `mcp_config.json`:** Open the file in a text editor. Add or modify the `mcpServers` section like this, **replacing `/PATH/TO/YOUR/CLONED/REPO` with the actual absolute path you copied in Step 6.1**:

    ```json
    {
      "mcpServers": {
        "google-docs-mcp": {
          "command": "node",
          "args": [
            "/PATH/TO/YOUR/CLONED/REPO/mcp-googledocs-server/dist/server.js"
          ],
          "env": {}
        }
        // Add commas here if you have other servers defined
      }
      // Other Claude settings might be here
    }
    ```

    - **Make sure the path in `"args"` is correct and absolute!**
    - If the file already existed, carefully merge this entry into the existing `mcpServers` object. Ensure the JSON is valid (check commas!).

4.  **Save `mcp_config.json`.**
5.  **Restart Claude Desktop:** Close Claude completely and reopen it.

---

## Usage with Claude Desktop

Once configured, you should be able to use the tools in your chats with Claude:

- "Use the `google-docs-mcp` server to read the document with ID `YOUR_GOOGLE_DOC_ID`."
- "Can you get the content of Google Doc `YOUR_GOOGLE_DOC_ID`?"
- "Append 'This was added by Claude!' to document `YOUR_GOOGLE_DOC_ID` using the `google-docs-mcp` tool."

Remember to replace `YOUR_GOOGLE_DOC_ID` with the actual ID from a Google Doc's URL (the long string between `/d/` and `/edit`).

Claude will automatically launch your server in the background when needed using the command you provided. You do **not** need to run `node ./dist/server.js` manually anymore.

---

## Security & Token Storage

- **`.gitignore`:** This repository includes a `.gitignore` file which should prevent you from accidentally committing your sensitive `credentials.json` and `token.json` files. **Do not remove these lines from `.gitignore`**.
- **Token Storage:** This server stores the Google authorization token (`token.json`) directly in the project folder for simplicity during setup. In production or more security-sensitive environments, consider storing this token more securely, such as using system keychains, encrypted files, or dedicated secret management services.

---

## Troubleshooting

- **Claude shows "Failed" or "Could not attach":**
  - Double-check the absolute path in `mcp_config.json`.
  - Ensure you ran `npm run build` successfully and the `dist` folder exists.
  - Try running the command from `mcp_config.json` manually in your terminal: `node /PATH/TO/YOUR/CLONED/REPO/mcp-googledocs-server/dist/server.js`. Look for any errors printed.
  - Check the Claude Desktop logs (see the official MCP debugging guide).
  - Make sure all `console.log` status messages in the server code were changed to `console.error`.
- **Google Authorization Errors:**
  - Ensure you enabled the correct APIs (Docs, Drive).
  - Make sure you added your email as a Test User on the OAuth Consent Screen.
  - Verify the `credentials.json` file is correctly placed in the project root.

---

## License

This project is licensed under the MIT License - see the `LICENSE` file for details. (Note: You should add a `LICENSE` file containing the MIT License text to your repository).

---
</file>

<file path="src/server.ts">
// src/server.ts
import { FastMCP, UserError } from 'fastmcp';
import { z } from 'zod';
import { google, docs_v1 } from 'googleapis';
import { authorize } from './auth.js';
import { OAuth2Client } from 'google-auth-library';

// --- Helper function for hex color validation (basic) ---
const hexColorRegex = /^#?([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/;
const validateHexColor = (color: string) => hexColorRegex.test(color);

// --- Helper function for Hex to RGB conversion ---
/**
 * Converts a hex color string to a Google Docs API RgbColor object.
 * @param hex - The hex color string (e.g., "#FF0000", "#F00", "FF0000").
 * @returns A Google Docs API RgbColor object or null if invalid.
 */
function hexToRgbColor(hex: string): docs_v1.Schema$RgbColor | null {
  if (!hex) return null;
  let hexClean = hex.startsWith('#') ? hex.slice(1) : hex;

  // Expand shorthand form (e.g. "F00") to full form (e.g. "FF0000")
  if (hexClean.length === 3) {
    hexClean = hexClean[0] + hexClean[0] + hexClean[1] + hexClean[1] + hexClean[2] + hexClean[2];
  }

  if (hexClean.length !== 6) {
    return null; // Invalid length
  }

  const bigint = parseInt(hexClean, 16);
  if (isNaN(bigint)) {
      return null; // Invalid hex characters
  }

  // Extract RGB values and normalize to 0.0 - 1.0 range
  const r = ((bigint >> 16) & 255) / 255;
  const g = ((bigint >> 8) & 255) / 255;
  const b = (bigint & 255) / 255;

  return { red: r, green: g, blue: b };
}

// --- Zod Schema for the formatText tool ---
// const FormatTextParameters = z.object({
//   documentId: z.string().describe('The ID of the Google Document.'),
//   startIndex: z.number().int().min(1).describe('The starting index of the text range (inclusive, starts from 1).'),
//   endIndex: z.number().int().min(1).describe('The ending index of the text range (inclusive).'),
//   // Optional Formatting Parameters (SHARED)
//   bold: z.boolean().optional().describe('Apply bold formatting.'),
//   italic: z.boolean().optional().describe('Apply italic formatting.'),
//   underline: z.boolean().optional().describe('Apply underline formatting.'),
//   strikethrough: z.boolean().optional().describe('Apply strikethrough formatting.'),
//   fontSize: z.number().min(1).optional().describe('Set font size (in points, e.g., 12).'),
//   fontFamily: z.string().optional().describe('Set font family (e.g., "Arial", "Times New Roman").'),
//   foregroundColor: z.string()
//     .refine(validateHexColor, { message: "Invalid hex color format (e.g., #FF0000 or #F00)" })
//     .optional()
//     .describe('Set text color using hex format (e.g., "#FF0000").'),
//   backgroundColor: z.string()
//     .refine(validateHexColor, { message: "Invalid hex color format (e.g., #00FF00 or #0F0)" })
//     .optional()
//     .describe('Set text background color using hex format (e.g., "#FFFF00").'),
//   linkUrl: z.string().url().optional().describe('Make the text a hyperlink pointing to this URL.')
// })
// .refine(data => data.endIndex >= data.startIndex, {
//   message: "endIndex must be greater than or equal to startIndex",
//   path: ["endIndex"],
// })
// .refine(data => Object.keys(data).some(key => !['documentId', 'startIndex', 'endIndex'].includes(key) && data[key as keyof typeof data] !== undefined), {
//     message: "At least one formatting option (bold, italic, fontSize, etc.) must be provided."
// });

// --- Define the TypeScript type based on the schema ---
// type FormatTextArgs = z.infer<typeof FormatTextParameters>;

// --- Zod Schema for the NEW formatMatchingText tool ---
const FormatMatchingTextParameters = z.object({
  documentId: z.string().describe('The ID of the Google Document.'),
  textToFind: z.string().min(1).describe('The exact text string to find and format.'),
  matchInstance: z.number().int().min(1).optional().default(1).describe('Which instance of the text to format (1st, 2nd, etc.). Defaults to 1.'),
  // Re-use optional Formatting Parameters (SHARED)
  bold: z.boolean().optional().describe('Apply bold formatting.'),
  italic: z.boolean().optional().describe('Apply italic formatting.'),
  underline: z.boolean().optional().describe('Apply underline formatting.'),
  strikethrough: z.boolean().optional().describe('Apply strikethrough formatting.'),
  fontSize: z.number().min(1).optional().describe('Set font size (in points, e.g., 12).'),
  fontFamily: z.string().optional().describe('Set font family (e.g., "Arial", "Times New Roman").'),
  foregroundColor: z.string()
    .refine(validateHexColor, { message: "Invalid hex color format (e.g., #FF0000 or #F00)" })
    .optional()
    .describe('Set text color using hex format (e.g., "#FF0000").'),
  backgroundColor: z.string()
    .refine(validateHexColor, { message: "Invalid hex color format (e.g., #00FF00 or #0F0)" })
    .optional()
    .describe('Set text background color using hex format (e.g., "#FFFF00").'),
  linkUrl: z.string().url().optional().describe('Make the text a hyperlink pointing to this URL.')
})
.refine(data => Object.keys(data).some(key => !['documentId', 'textToFind', 'matchInstance'].includes(key) && data[key as keyof typeof data] !== undefined), {
    message: "At least one formatting option (bold, italic, fontSize, etc.) must be provided."
});

// --- Define the TypeScript type based on the new schema ---
type FormatMatchingTextArgs = z.infer<typeof FormatMatchingTextParameters>;

// --- Helper function to build TextStyle and fields mask (reusable) ---
function buildTextStyleAndFields(args: Omit<FormatMatchingTextArgs, 'documentId' | 'textToFind' | 'matchInstance'>): { textStyle: docs_v1.Schema$TextStyle, fields: string[] } {
    const textStyle: docs_v1.Schema$TextStyle = {};
    const fieldsToUpdate: string[] = [];

    if (args.bold !== undefined) { textStyle.bold = args.bold; fieldsToUpdate.push('bold'); }
    if (args.italic !== undefined) { textStyle.italic = args.italic; fieldsToUpdate.push('italic'); }
    if (args.underline !== undefined) { textStyle.underline = args.underline; fieldsToUpdate.push('underline'); }
    if (args.strikethrough !== undefined) { textStyle.strikethrough = args.strikethrough; fieldsToUpdate.push('strikethrough'); }
    if (args.fontSize !== undefined) {
        textStyle.fontSize = { magnitude: args.fontSize, unit: 'PT' };
        fieldsToUpdate.push('fontSize');
    }
    if (args.fontFamily !== undefined) {
        textStyle.weightedFontFamily = { fontFamily: args.fontFamily };
        fieldsToUpdate.push('weightedFontFamily');
    }
    if (args.foregroundColor !== undefined) {
        const rgbColor = hexToRgbColor(args.foregroundColor);
        if (!rgbColor) throw new UserError(`Invalid foreground hex color format: ${args.foregroundColor}`);
        textStyle.foregroundColor = { color: { rgbColor: rgbColor } };
        fieldsToUpdate.push('foregroundColor');
    }
    if (args.backgroundColor !== undefined) {
        const rgbColor = hexToRgbColor(args.backgroundColor);
        if (!rgbColor) throw new UserError(`Invalid background hex color format: ${args.backgroundColor}`);
        textStyle.backgroundColor = { color: { rgbColor: rgbColor } };
        fieldsToUpdate.push('backgroundColor');
    }
    if (args.linkUrl !== undefined) {
        textStyle.link = { url: args.linkUrl };
        fieldsToUpdate.push('link');
    }

    if (fieldsToUpdate.length === 0) {
        // This should ideally be caught by Zod refine, but defensive check
        throw new UserError("No formatting options were specified.");
    }

    return { textStyle, fields: fieldsToUpdate };
}

let authClient: OAuth2Client | null = null;
let googleDocs: docs_v1.Docs | null = null;

async function initializeGoogleClient() {
  if (googleDocs) return { authClient, googleDocs };
  if (authClient === null && googleDocs === null) {
    try {
      console.error("Attempting to authorize Google API client...");
      const client = await authorize();
      if (client) {
        authClient = client;
        googleDocs = google.docs({ version: 'v1', auth: authClient });
        console.error("Google API client authorized successfully.");
      } else {
        console.error("FATAL: Authorization returned null or undefined client.");
        authClient = null;
        googleDocs = null;
      }
    } catch (error) {
      console.error("FATAL: Failed to initialize Google API client:", error);
      authClient = null;
      googleDocs = null;
    }
  }
  return { authClient, googleDocs };
}

const server = new FastMCP({
  name: 'Google Docs MCP Server',
  version: '1.0.0',
});

// Tool: Read Google Doc
server.addTool({
  name: 'readGoogleDoc',
  description: 'Reads the content of a specific Google Document.',
  parameters: z.object({
    documentId: z.string().describe('The ID of the Google Document (from the URL).'),
  }),
  execute: async (args, { log }) => {
    const { googleDocs: docs } = await initializeGoogleClient();
    if (!docs) throw new UserError("Google Docs client not initialized.");

    log.info(`Reading Google Doc: ${args.documentId}`);
    try {
      const res = await docs.documents.get({
        documentId: args.documentId,
        fields: 'body(content)',
      });
      log.info(`Fetched doc: ${args.documentId}`);

      let textContent = '';
      res.data.body?.content?.forEach(element => {
        element.paragraph?.elements?.forEach(pe => {
          textContent += pe.textRun?.content || '';
        });
      });

      if (!textContent.trim()) return "Document found, but appears empty.";

      const maxLength = 2000;
      const truncatedContent = textContent.length > maxLength ? textContent.substring(0, maxLength) + '... [truncated]' : textContent;
      return `Content:\n---\n${truncatedContent}`;
    } catch (error: any) {
      log.error(`Error reading doc ${args.documentId}: ${error.message}`);
       if (error.code === 404) throw new UserError(`Doc not found (ID: ${args.documentId}).`);
       if (error.code === 403) throw new UserError(`Permission denied for doc (ID: ${args.documentId}).`);
       throw new UserError(`Failed to read doc: ${error.message}`);
    }
  },
});

// Tool: Append to Google Doc
server.addTool({
  name: 'appendToGoogleDoc',
  description: 'Appends text to the end of a specific Google Document.',
  parameters: z.object({
    documentId: z.string().describe('The ID of the Google Document.'),
    textToAppend: z.string().describe('The text to add.'),
  }),
  execute: async (args, { log }) => {
    const { googleDocs: docs } = await initializeGoogleClient();
     if (!docs) throw new UserError("Google Docs client not initialized.");

    log.info(`Appending to Google Doc: ${args.documentId}`);
    try {
      const docInfo = await docs.documents.get({ documentId: args.documentId, fields: 'body(content)' });
      let endIndex = 1;
      if (docInfo.data.body?.content) {
        const lastElement = docInfo.data.body.content[docInfo.data.body.content.length - 1];
        if (lastElement?.endIndex) endIndex = lastElement.endIndex - 1;
      }
      const textToInsert = (endIndex > 1 && !args.textToAppend.startsWith('\n') ? '\n' : '') + args.textToAppend;

      await docs.documents.batchUpdate({
        documentId: args.documentId,
        requestBody: { requests: [{ insertText: { location: { index: endIndex }, text: textToInsert } }] },
      });

      log.info(`Successfully appended to doc: ${args.documentId}`);
      return `Successfully appended text to document ${args.documentId}.`;
    } catch (error: any) {
      log.error(`Error editing doc ${args.documentId}: ${error.message}`);
      if (error.code === 404) throw new UserError(`Doc not found (ID: ${args.documentId}).`);
      if (error.code === 403) throw new UserError(`Permission denied for doc (ID: ${args.documentId}).`);
      throw new UserError(`Failed to edit doc: ${error.message}`);
    }
  },
});

// --- Add the formatMatchingText tool ---
server.addTool({
    name: 'formatMatchingText',
    description: 'Finds specific text within a Google Document and applies character formatting (bold, italics, color, etc.) to the specified instance.',
    parameters: FormatMatchingTextParameters, // Use the new Zod schema
    execute: async (args: FormatMatchingTextArgs, { log }) => {
        const { googleDocs: docs } = await initializeGoogleClient();
        if (!docs) {
          throw new UserError("Google Docs client is not initialized. Authentication might have failed.");
        }

        log.info(`Attempting to find text "${args.textToFind}" (instance ${args.matchInstance}) in doc: ${args.documentId} and format it.`);

        // 1. Get the document content to find the text range
        let docContent: docs_v1.Schema$Document;
        try {
            const res = await docs.documents.get({
                documentId: args.documentId,
                // Request fields needed to reconstruct text and find indices
                fields: 'body(content(paragraph(elements(startIndex,endIndex,textRun(content)))))',
            });
            docContent = res.data;
            if (!docContent.body?.content) {
                throw new UserError(`Document body or content is empty or inaccessible (ID: ${args.documentId}).`);
            }
            log.info(`Fetched doc content for searching: ${args.documentId}`);
        } catch (error: any) {
            log.error(`Error retrieving doc ${args.documentId} for search: ${error.message}`);
            if (error.code === 404) throw new UserError(`Doc not found (ID: ${args.documentId}).`);
            if (error.code === 403) throw new UserError(`Permission denied for doc (ID: ${args.documentId}).`);
            throw new UserError(`Failed to retrieve doc for searching: ${error.message}`);
        }

        // 2. Find the Nth instance of the text and its range
        let fullText = '';
        const textSegments: { text: string, start: number, end: number }[] = [];
        docContent.body.content.forEach(element => {
            element.paragraph?.elements?.forEach(pe => {
                if (pe.textRun?.content && pe.startIndex && pe.endIndex) {
                    // Handle potential line breaks within content
                    const content = pe.textRun.content;
                    fullText += content;
                    textSegments.push({
                        text: content,
                        start: pe.startIndex,
                        end: pe.endIndex
                    });
                }
            });
        });

        let startIndex = -1;
        let endIndex = -1;
        let foundCount = 0;
        let searchStartIndex = 0;

        while (foundCount < args.matchInstance) {
            const currentIndex = fullText.indexOf(args.textToFind, searchStartIndex);
            if (currentIndex === -1) {
                // Text not found anymore
                break;
            }
            foundCount++;
            if (foundCount === args.matchInstance) {
                // Found the start of the Nth match in the *reconstructed* string.
                // Map this back to the API's startIndex/endIndex.
                const targetStartInFullText = currentIndex;
                const targetEndInFullText = currentIndex + args.textToFind.length;
                let currentPosInFullText = 0;

                for (const seg of textSegments) {
                    const segStartInFullText = currentPosInFullText;
                    // Length of segment text might differ from index range if it contains newlines etc.
                    const segTextLength = seg.text.length;
                    const segEndInFullText = segStartInFullText + segTextLength;

                     // Check if the target *starts* within this segment's text span
                    if (startIndex === -1 && targetStartInFullText >= segStartInFullText && targetStartInFullText < segEndInFullText) {
                        // Calculate the API start index relative to the segment's start index
                        startIndex = seg.start + (targetStartInFullText - segStartInFullText);
                    }

                    // Check if the target *ends* within this segment's text span
                     if (targetEndInFullText > segStartInFullText && targetEndInFullText <= segEndInFullText) {
                        // Calculate the API end index relative to the segment's start index
                        endIndex = seg.start + (targetEndInFullText - segStartInFullText);
                        break; // Found the end, we have the full range
                    }

                    currentPosInFullText = segEndInFullText;
                }

                if (startIndex === -1 || endIndex === -1) {
                     log.warn(`Could not accurately map indices for match ${foundCount} of "${args.textToFind}". Start found at ${targetStartInFullText}, End at ${targetEndInFullText}. Resetting.`);
                     // Reset if we couldn't map indices correctly for this match
                     startIndex = -1;
                     endIndex = -1;
                     // Don't break the outer loop, let it try searching again
                }
            }
            // Continue searching after the start of the current match to find subsequent occurrences
            searchStartIndex = currentIndex + 1;
        }


        if (startIndex === -1 || endIndex === -1) {
          throw new UserError(`Could not find instance ${args.matchInstance} of the text "${args.textToFind}" in document ${args.documentId}. Found ${foundCount} total instance(s).`);
        }

        log.info(`Found text "${args.textToFind}" (instance ${args.matchInstance}) at mapped range: ${startIndex}-${endIndex}`);

        // 3. Build the TextStyle object and fields mask
        const { textStyle, fields } = buildTextStyleAndFields(args);


        // 4. Build the UpdateTextStyleRequest
        const updateTextStyleRequest: docs_v1.Schema$UpdateTextStyleRequest = {
            range: {
                // API uses segmentId, but omitting it defaults to the document BODY
                startIndex: startIndex, // Use the calculated start index
                endIndex: endIndex,     // Use the calculated end index
            },
            textStyle: textStyle,
            fields: fields.join(','), // Crucial: Tells API which fields to update
        };

        // 5. Send the batchUpdate request
        try {
            await docs.documents.batchUpdate({
                documentId: args.documentId,
                requestBody: {
                    requests: [{ updateTextStyle: updateTextStyleRequest }],
                },
            });
            log.info(`Successfully formatted text in doc: ${args.documentId}, range: ${startIndex}-${endIndex}`);
            return `Successfully applied formatting to instance ${args.matchInstance} of "${args.textToFind}".`;
        } catch (error: any) {
            log.error(`Error formatting text in doc ${args.documentId}: ${error.message}`);
            // Consider more specific error handling based on API response if needed
            throw new UserError(`Failed to apply formatting: ${error.message}`);
        }
    },
});

// Tool: Format Text (existing, keep for index-based formatting if needed)
// server.addTool({
//   name: 'formatText',
//   description: 'Applies character formatting (bold, italics, font size, color, link, etc.) to a specific text range in a Google Document using start/end indices.',
//   parameters: FormatTextParameters, // Use the original Zod schema
//   execute: async (args: FormatTextArgs, { log }) => {
//     const { googleDocs: docs } = await initializeGoogleClient();
//     if (!docs) {
//       throw new UserError("Google Docs client is not initialized. Authentication might have failed.");
//     }
//
//     log.info(`Attempting to format text in doc: ${args.documentId}, range: ${args.startIndex}-${args.endIndex}`);
//
//     // 1. Build the TextStyle object and fields mask
//     const { textStyle, fields } = buildTextStyleAndFields(args);
//
//     // 2. Build the UpdateTextStyleRequest
//     const updateTextStyleRequest: docs_v1.Schema$UpdateTextStyleRequest = {
//       range: {
//         startIndex: args.startIndex,
//         endIndex: args.endIndex,
//       },
//       textStyle: textStyle,
//       fields: fields.join(','),
//     };
//
//     // 3. Send the batchUpdate request
//     try {
//       await docs.documents.batchUpdate({
//         documentId: args.documentId,
//         requestBody: {
//           requests: [{ updateTextStyle: updateTextStyleRequest }],
//         },
//       });
//       log.info(`Successfully formatted text in doc: ${args.documentId}, range: ${args.startIndex}-${args.endIndex}`);
//       return `Successfully applied formatting to range ${args.startIndex}-${args.endIndex}.`;
//     } catch (error: any) {
//       log.error(`Error formatting text in doc ${args.documentId}: ${error.message}`);
//        if (error.code === 404) throw new UserError(`Doc not found (ID: ${args.documentId}).`);
//        if (error.code === 403) throw new UserError(`Permission denied for doc (ID: ${args.documentId}).`);
//       throw new UserError(`Failed to format text: ${error.message}`);
//     }
//   },
// });

// Start the Server (Modified to avoid server.config issue)
async function startServer() {
  await initializeGoogleClient(); // Authorize before starting listeners
  console.error("Starting MCP server...");
  try {
      const configToUse = {
        // Choose one transport:
         transportType: "stdio" as const,
        //  transportType: "sse" as const,
        //  sse: {                       // <-- COMMENT OUT or DELETE SSE config
        //    endpoint: "/sse" as const,
        //    port: 8080,
        //  },
      };

      server.start(configToUse); // Start the server with stdio config

      // Adjust logging (optional, but good practice)
      console.error(`MCP Server running using ${configToUse.transportType}.`);
      if (configToUse.transportType === 'stdio') {
          console.error("Awaiting MCP client connection via stdio...");
      }
      // Removed SSE-specific logging

  } catch(startError) {
      console.error("Error occurred during server.start():", startError);
      throw startError; // Re-throw to be caught by the outer catch
  }
}

// Call the modified startServer function
startServer().catch(err => {
    console.error("Server failed to start:", err);
    process.exit(1);
});
</file>

<file path="README.md">
# Claude MCP x Google Docs

![Demo Animation](assets/google.docs.mcp.1.gif)

Connect Claude Desktop (or other MCP clients) to your Google Docs!

This server uses the Model Context Protocol (MCP) and the `fastmcp` library to provide tools for reading and appending text to Google Documents. It acts as a bridge, allowing AI assistants like Claude to interact with your documents programmatically.

**Features:**

- **Read Documents:** Provides a `readGoogleDoc` tool to fetch the text content of a specified Google Doc.
- **Append to Documents:** Provides an `appendToGoogleDoc` tool to add text to the end of a specified Google Doc.
- **Format Text (by Content):** Provides a `formatMatchingText` tool to find specific text and apply character formatting (bold, color, etc.) to it. This is the primary method for formatting.
- **Google Authentication:** Handles the OAuth 2.0 flow to securely authorize access to your Google Account.
- **MCP Compliant:** Designed for use with MCP clients like Claude Desktop.

---

## Prerequisites

Before you start, make sure you have:

1.  **Node.js and npm:** A recent version of Node.js (which includes npm) installed on your computer. You can download it from [nodejs.org](https://nodejs.org/). (Version 18 or higher recommended).
2.  **Git:** Required for cloning this repository. ([Download Git](https://git-scm.com/downloads)).
3.  **A Google Account:** The account that owns or has access to the Google Docs you want to interact with.
4.  **Command Line Familiarity:** Basic comfort using a terminal or command prompt (like Terminal on macOS/Linux, or Command Prompt/PowerShell on Windows).
5.  **Claude Desktop (Optional):** If your goal is to connect this server to Claude, you'll need the Claude Desktop application installed.

---

## Setup Instructions

Follow these steps carefully to get your own instance of the server running.

### Step 1: Google Cloud Project & Credentials (The Important Bit!)

This server needs permission to talk to Google APIs on your behalf. You'll create special "keys" (credentials) that only your server will use.

1.  **Go to Google Cloud Console:** Open your web browser and go to the [Google Cloud Console](https://console.cloud.google.com/). You might need to log in with your Google Account.
2.  **Create or Select a Project:**
    - If you don't have a project, click the project dropdown near the top and select "NEW PROJECT". Give it a name (e.g., "My MCP Docs Server") and click "CREATE".
    - If you have existing projects, you can select one or create a new one.
3.  **Enable APIs:** You need to turn on the specific Google services this server uses.
    - In the search bar at the top, type "APIs & Services" and select "Library".
    - Search for "**Google Docs API**" and click on it. Then click the "**ENABLE**" button.
    - Search for "**Google Drive API**" and click on it. Then click the "**ENABLE**" button (this is often needed for finding files or permissions).
4.  **Configure OAuth Consent Screen:** This screen tells users (usually just you) what your app wants permission for.
    - On the left menu, click "APIs & Services" -> "**OAuth consent screen**".
    - Choose User Type: Select "**External**" and click "CREATE".
    - Fill in App Information:
      - **App name:** Give it a name users will see (e.g., "Claude Docs MCP Access").
      - **User support email:** Select your email address.
      - **Developer contact information:** Enter your email address.
    - Click "**SAVE AND CONTINUE**".
    - **Scopes:** Click "**ADD OR REMOVE SCOPES**". Search for and add the following scopes:
      - `https://www.googleapis.com/auth/documents` (Allows reading/writing docs)
      - `https://www.googleapis.com/auth/drive.file` (Allows access to specific files opened/created by the app)
      - Click "**UPDATE**".
    - Click "**SAVE AND CONTINUE**".
    - **Test Users:** Click "**ADD USERS**". Enter the same Google email address you are logged in with. Click "**ADD**". This allows _you_ to use the app while it's in "testing" mode.
    - Click "**SAVE AND CONTINUE**". Review the summary and click "**BACK TO DASHBOARD**".
5.  **Create Credentials (The Keys!):**
    - On the left menu, click "APIs & Services" -> "**Credentials**".
    - Click "**+ CREATE CREDENTIALS**" at the top and choose "**OAuth client ID**".
    - **Application type:** Select "**Desktop app**" from the dropdown.
    - **Name:** Give it a name (e.g., "MCP Docs Desktop Client").
    - Click "**CREATE**".
6.  **⬇️ DOWNLOAD THE CREDENTIALS FILE:** A box will pop up showing your Client ID. Click the "**DOWNLOAD JSON**" button.
    - Save this file. It will likely be named something like `client_secret_....json`.
    - **IMPORTANT:** Rename the downloaded file to exactly `credentials.json`.
7.  ⚠️ **SECURITY WARNING:** Treat this `credentials.json` file like a password! Do not share it publicly, and **never commit it to GitHub.** Anyone with this file could potentially pretend to be _your application_ (though they'd still need user consent to access data).

### Step 2: Get the Server Code

1.  **Clone the Repository:** Open your terminal/command prompt and run:
    ```bash
    git clone https://github.com/a-bonus/google-docs-mcp.git mcp-googledocs-server
    ```
2.  **Navigate into Directory:**
    ```bash
    cd mcp-googledocs-server
    ```
3.  **Place Credentials:** Move or copy the `credentials.json` file you downloaded and renamed (from Step 1.6) directly into this `mcp-googledocs-server` folder.

### Step 3: Install Dependencies

Your server needs some helper libraries specified in the `package.json` file.

1.  In your terminal (make sure you are inside the `mcp-googledocs-server` directory), run:
    ```bash
    npm install
    ```
    This will download and install all the necessary packages into a `node_modules` folder.

### Step 4: Build the Server Code

The server is written in TypeScript (`.ts`), but we need to compile it into JavaScript (`.js`) that Node.js can run directly.

1.  In your terminal, run:
    ```bash
    npm run build
    ```
    This uses the TypeScript compiler (`tsc`) to create a `dist` folder containing the compiled JavaScript files.

### Step 5: First Run & Google Authorization (One Time Only)

Now you need to run the server once manually to grant it permission to access your Google account data. This will create a `token.json` file that saves your permission grant.

1.  In your terminal, run the _compiled_ server using `node`:
    ```bash
    node ./dist/server.js
    ```
2.  **Watch the Terminal:** The script will print:
    - Status messages (like "Attempting to authorize...").
    - An "Authorize this app by visiting this url:" message followed by a long `https://accounts.google.com/...` URL.
3.  **Authorize in Browser:**
    - Copy the entire long URL from the terminal.
    - Paste the URL into your web browser and press Enter.
    - Log in with the **same Google account** you added as a Test User in Step 1.4.
    - Google will show a screen asking for permission for your app ("Claude Docs MCP Access" or similar) to access Google Docs/Drive. Review and click "**Allow**" or "**Grant**".
4.  **Get the Authorization Code:**
    - After clicking Allow, your browser will likely try to redirect to `http://localhost` and show a **"This site can't be reached" error**. **THIS IS NORMAL!**
    - Look **carefully** at the URL in your browser's address bar. It will look like `http://localhost/?code=4/0Axxxxxxxxxxxxxx&scope=...`
    - Copy the long string of characters **between `code=` and the `&scope` part**. This is your single-use authorization code.
5.  **Paste Code into Terminal:** Go back to your terminal where the script is waiting ("Enter the code from that page here:"). Paste the code you just copied.
6.  **Press Enter.**
7.  **Success!** The script should print:
    - "Authentication successful!"
    - "Token stored to .../token.json"
    - It will then finish starting and likely print "Awaiting MCP client connection via stdio..." or similar, and then exit (or you can press `Ctrl+C` to stop it).
8.  ✅ **Check:** You should now see a new file named `token.json` in your `mcp-googledocs-server` folder.
9.  ⚠️ **SECURITY WARNING:** This `token.json` file contains the key that allows the server to access your Google account _without_ asking again. Protect it like a password. **Do not commit it to GitHub.** The included `.gitignore` file should prevent this automatically.

### Step 6: Configure Claude Desktop (Optional)

If you want to use this server with Claude Desktop, you need to tell Claude how to run it.

1.  **Find Your Absolute Path:** You need the full path to the server code.
    - In your terminal, make sure you are still inside the `mcp-googledocs-server` directory.
    - Run the `pwd` command (on macOS/Linux) or `cd` (on Windows, just displays the path).
    - Copy the full path (e.g., `/Users/yourname/projects/mcp-googledocs-server` or `C:\Users\yourname\projects\mcp-googledocs-server`).
2.  **Locate `mcp_config.json`:** Find Claude's configuration file:
    - **macOS:** `~/Library/Application Support/Claude/mcp_config.json` (You might need to use Finder's "Go" -> "Go to Folder..." menu and paste `~/Library/Application Support/Claude/`)
    - **Windows:** `%APPDATA%\Claude\mcp_config.json` (Paste `%APPDATA%\Claude` into File Explorer's address bar)
    - **Linux:** `~/.config/Claude/mcp_config.json`
    - _If the `Claude` folder or `mcp_config.json` file doesn't exist, create them._
3.  **Edit `mcp_config.json`:** Open the file in a text editor. Add or modify the `mcpServers` section like this, **replacing `/PATH/TO/YOUR/CLONED/REPO` with the actual absolute path you copied in Step 6.1**:

    ```json
    {
      "mcpServers": {
        "google-docs-mcp": {
          "command": "node",
          "args": [
            "/PATH/TO/YOUR/CLONED/REPO/mcp-googledocs-server/dist/server.js"
          ],
          "env": {}
        }
        // Add commas here if you have other servers defined
      }
      // Other Claude settings might be here
    }
    ```

    - **Make sure the path in `"args"` is correct and absolute!**
    - If the file already existed, carefully merge this entry into the existing `mcpServers` object. Ensure the JSON is valid (check commas!).

4.  **Save `mcp_config.json`.**
5.  **Restart Claude Desktop:** Close Claude completely and reopen it.

---

## Usage with Claude Desktop

Once configured, you should be able to use the tools in your chats with Claude:

- "Use the `google-docs-mcp` server to read the document with ID `YOUR_GOOGLE_DOC_ID`."
- "Can you get the content of Google Doc `YOUR_GOOGLE_DOC_ID`?"
- "Append 'This was added by Claude!' to document `YOUR_GOOGLE_DOC_ID` using the `google-docs-mcp` tool."
- "Using `google-docs-mcp`, make the text 'Important Section' bold in document `YOUR_GOOGLE_DOC_ID` using the `formatMatchingText` tool."
- "Use `formatMatchingText` via `google-docs-mcp` to find the first instance of 'Project Alpha' and make it blue (#0000FF) in doc `YOUR_GOOGLE_DOC_ID`."

Remember to replace `YOUR_GOOGLE_DOC_ID` with the actual ID from a Google Doc's URL (the long string between `/d/` and `/edit`).

Claude will automatically launch your server in the background when needed using the command you provided. You do **not** need to run `node ./dist/server.js` manually anymore.

---

## Security & Token Storage

- **`.gitignore`:** This repository includes a `.gitignore` file which should prevent you from accidentally committing your sensitive `credentials.json` and `token.json` files. **Do not remove these lines from `.gitignore`**.
- **Token Storage:** This server stores the Google authorization token (`token.json`) directly in the project folder for simplicity during setup. In production or more security-sensitive environments, consider storing this token more securely, such as using system keychains, encrypted files, or dedicated secret management services.

---

## Troubleshooting

- **Claude shows "Failed" or "Could not attach":**
  - Double-check the absolute path in `mcp_config.json`.
  - Ensure you ran `npm run build` successfully and the `dist` folder exists.
  - Try running the command from `mcp_config.json` manually in your terminal: `node /PATH/TO/YOUR/CLONED/REPO/mcp-googledocs-server/dist/server.js`. Look for any errors printed.
  - Check the Claude Desktop logs (see the official MCP debugging guide).
  - Make sure all `console.log` status messages in the server code were changed to `console.error`.
- **Google Authorization Errors:**
  - Ensure you enabled the correct APIs (Docs, Drive).
  - Make sure you added your email as a Test User on the OAuth Consent Screen.
  - Verify the `credentials.json` file is correctly placed in the project root.

---

## License

This project is licensed under the MIT License - see the `LICENSE` file for details. (Note: You should add a `LICENSE` file containing the MIT License text to your repository).
</file>

</files>
